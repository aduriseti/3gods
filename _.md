I was introduced to the 3-gods problem (somewhat cruelly) a few months ago by a college friend while we were catching up over some bbq. I can't remember what we were talking about - but I do remember him saying something along the lines of "Here's a very easy logic problem for you (very )

A few months ago I was catching up with a friend over some barbeque and he posed an interesting logic puzzle to me:

"Heres an easy riddle (I'm paraphrasing): there are 3 gods in front of you, one who always answers truely, one who always answers falsely, and one who always answers randomly. Your goal is to determine the identity of each code using 3 yes/no questions. Oh - and the gods answer in their own language although they understand English. So they will answer with ja/da - and you don't know which means yes and which means no."

Well - I can't remember what we were talking about before - but I guess I must have been razzing him b/c this is not an easy problem! Famously - this is the so-called "Hardest Logic Puzzle Ever" (https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever). Well - he got me (I think the term is nerd-sniping?). I thought about it a good deal on the drive home - and that night - and the day after - and the day after that ---- actually it took me a long time to figure this one out.

If you  writeups and explanations are available on wikipedia (https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever#Solutions).

Instead I want to talk about my formal method of solving this problem with logic programming - which AFAIK no one has actually done before.

 (although you could definitely also frame this as a SMT problem and solve it using S3 or something). I actually think this a novel approach - to the best of my knowledge no one has ever solved this problem using logic programming of any kind.

After solving this puzzle - I had the idea that it might be interesting to solve this problem using a more formal methid. I spent a little time trying to solve it with boolean algebra (actually someone wrote a [paper](https://www.researchgate.net/publication/339489184_Solving_Knights-and-Knaves_with_One_Equation) doing just this) - but I just couldn't quite make it work. Once I had an objective in mind (say - determining the identity of a non-random god), I was able to write a system of equations and plug them into mathmatica to produce a question that allowed me to achieve my objective, but I wasn't able to formalize the process of arriving at an objective. And then I had absolutely no idea how to further extend this approach to handle branching logic and question trees.

Eventually I remembered some week long unit from my programming languages class on Prolog. Prolog is a delarative programming language (like SQL, or I guess tensorflow v1?) as opposed to imperative programming languages like Python/C++/go/rust/etc... (also tensorflow v2). What you do is specify known facts about the world (e.g. sky is blue, I am looking at the sky) and let Prolog's engine solve for unknowns (The color of the thing I am looking as is \_\_\_\_ --- and in this case Prolog would fill in `blue` for the blank).

## Knight or Knave
Lets first see how we might use Prolog to solve a much simpler problem. Say there is a single god in front of us, who may be either the Truely or Falsely god - and we want to determine its identity in 1 question. As a human - easy - just ask the god a trivially true question like "Is 1 == 1?". If they say yes - they are the Truely god - if they say no they are the falsely god. For Prolog to discover this same question - we need
1. Constraints defining the world (a single god, who may be of 2 different types, each of which who answer questions differently)
2. Constraints on questions - here we define a grammar. For this world we only need the atomic trivially true question mentioned earlier, but we can also add some other grammar rules. For example, composition via AND and OR operators, etc... 
3. Constrains on how questions are evaluated by our world. This is where we encode our objective - which is that our desired question can differentiate the possible worldstates. Or - in other words - that when we pose our question tothe god in front of us,  it yields different responses for different worldstates.

What does this actually look like?

World constraints are very simple - we have a single position, and it may be inhabited by 2 different gods:
```prolog
is_position(a).

is_god(truly).
is_god(falsely).
```

Similarly our question grammar can be very simple. We only need an "atomic" true question - which we can imagine as "Is 1==1?" or some other axiomatic statement. But thats a little boring - lets at least give our Prolog program a chance to fail and ask a useless question. For example - "Will the god at position `a` answer the question "1==1" with yes?". The Truely - god - truthfully - will say yes. The Falsely god - deceitfully - will also say yes.
```prolog
% Axiomatically true questions are allowed.
is_question(true).

% Questions about how gods at positions might respond to questions are allowed.
is_question(query_position_question(Pos, Q)) :- is_position(Pos), is_question(Q).
```

This question grammar requires a corresponding evalaution framework - for this we define an evaluation predicate `evaluate(Question, WorldState)`: 
```prolog
% Note that axiomatic questions do not require the worldstate for evaluation
evaluate(true, _) :- true.

% (`query_position` is the predicate which evalautes the result of posing a question to a God. It is explained in more detail below - because we allow self-referential questions explaining this code creates a bootstrapping problem :O)
evaluate(query_position_question(P, Q), WS) :- query_position(P, Q, WS).
```

We encode the different behavior of the gods by how they evaluate questions - the Truly god returns the logical value of the proposition 
represented by a question as evaluated by Prolog's engine - the Falsely god returns its negation:
```prolog
query(truly, Question, WorldState) :-
    evaluate(Question, WorldState).

% (\+ is the negation operator in Prolog)
query(falsely, Question, WorldState) :-
    \+ evaluate(Question, WorldState).
```

We also need a way to pose these questions to gods at a specific position:
```prolog
query_position(Position, Question, WorldState) :- 
        is_position(Position), is_god(GodType), query(GodType, Question, WorldState).
```

Finally we can synthesize the constraints above with a predicate that forces the 2 possible worldstates (the god in front of you is Truely or Falsely) to give different responses for a question:
```prolog
is_distinguishing_question(Question, AnswerForTruly, AnswerForFalsely) :-
    is_question(Question),
	(query_position(a, Question, truly)
    	-> AnswerForTruly = true ; AnswerForTruly = fail),
    (query_position(a, Question, falsely)
    	-> AnswerForFalsely = true ; AnswerForFalsely = fail),
    AnswerForTruly \= AnswerForFalsely.
```

The predicate above can be used in 2 ways:
1. We can invoke it w/ an unconstrained question: `is_distinguishing_question(Q, _, _).`. This will produce all distinguishing questions (you can cycle through all results w/ `;`).
2. We can also invoke it 

You can play around w/ this simplified problem and its solution in the embedded playground below ([full screen](https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/knight_or_knave.pl&q=is_distinguishing_question(Q,_,_).)):

<iframe src="https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/knight_or_knave.pl&q=is_distinguishing_question(Q,_,_)." 
        width="100%" 
        height="600px" 
        style="border: 1px solid #ccc; border-radius: 4px;">
</iframe>

## Extending to the full 3-gods puzzle
Ok - so how do we extend tha pproach above to the full 3-gods problem? Off the top of my head (as I mentally retrace my steps)- we need
1. Support for the random god
2. Multiple gods (multiple positions) & multiple questions
3. The language of the gods (ja/da)

### Random god
Implementing the random god I accomplished by encoding all possible future answers of the random god into the worldstate. When we pose a question to a random god, instead of evaluating that question, we just look up a random answer from its set of predetermined random responses:
```prolog
query(random, _Question, Path, _WorldState, RndAnsList) :-
    length(Path, NumPreviousAnswers),
    CurrentQuestionNum is NumPreviousAnswers + 1,
    nth1(CurrentQuestionNum, RndAnsList, Answer),
    Answer. % Succeeds if the Nth answer is 'true'
```

Note that this is actually not the only possible interpretation of how the random god answers questions. The original wording of this puzzle describes the behavior of the random god as:

> Three gods A, B, and C are called, in no particular order, True, False, and Random. True always speaks truly, False always speaks falsely, **but whether Random speaks truly or falsely is a completely random matter**.

In my implementation, I interpreted this as - the response of the random god is randomly "yes" or "no" (actually "ja" and "da"). However - another possible interpretation is that the Random gods response must be randomly true or false. The difference is subtle, but there are questions that can be posed for which is not possible to answer "no" either truly or falsely. An example would be the useless question earlier: "Would you answer the question "1==1" with yes?". For such questions, depending on your interpretation of the Random god, it may not be able to answer "no". In fact, if you assume that the Random gods answer must be either true or false, this puzzle is a lot easier and can even be answered in 2 questions (although you have to use paradoxical questions) - see [this paper](https://www.researchgate.net/publication/31366417_A_simple_solution_to_the_hardest_logic_puzzle_ever) for more details.

I decided to interpret this puzzle as:

> Three gods A, B, and C are called, in some order,‘True’, ‘False’, and ‘Random’. True always speaks truly, False always speaks falsely, but **whether Random answers ‘ja’ or ‘da’ is a completely random matter**.

And therefore allow the random god to potentially answer questions neither truly nor falsely.

### Multiple gods & questions
Multiple gods is easy - we can just parameterize our `is_position` clause:
```prolog
is_position(P) :-
    num_positions(N),
    between(1, N, P).

num_positions(3).
```

The biggest change is that we go from 2 possible worldstates (where the god in front of you is either Truly or Falsely) to 6 - for all permutations of 3 distinct gods A,B,C. Clearly - we now need multiple questions to differentiate these possible worldstates.

Note that if we are allowed multiple questions (3 for this puzzle), we don't just have to find $N$ questions - we actually have to find $2^N-1$ questions to build up a tree. Each question will be a node, and edges will 

Our goal in constructing this tree is that by the time we reach a leaf node (asked our last question), only a single possible worldstate (permutation of gods) will have been able to give the sequence of answers that navigates to this leaf node (e.g. "ja,da,da"). This process is illustrated below for some hypothetical questions and permutation partitions: 
```text
                     All 6 Permutations Possible
                   {TFR, TRF, FTR, FRT, RTF, RFT}
                                   |
                                 ( Q1 )
                                   |
                  +----------------+----------------+
                  |                                 |
               ( da )                            ( ja )
                  |                                 |
        {TRF, FRT, RTF, RFT}              {TFR, FTR, RTF, RFT}                        
                  |                                 |
               ( Q2 )                            ( Q3 )
                  |                                 |
         +--------+--------+               +--------+--------+
         |                 |               |                 |
      ( da )            ( ja )          ( da )            ( ja )
         |                 |               |                 |
     {TRF, RTF }       {FRT, RFT}      {FTR, RTF}        {TFR, RFT}
         |                 |               |                 |
      ( Q4 )            ( Q5 )          ( Q6 )            ( Q7 )
         |                 |               |                 |
    +----+----+       +----+----+     +----+----+       +----+----+
    |         |       |         |     |         |       |         |
  (TRF)     (RTF)   (FRT)     (RFT) (FTR)     (RTF)   (TFR)     (RFT)
```

### Language of the gods
Accomodating the language of the gods was actually the easiest extension - all it required was adding a translation layer to our predicate posing questions to gods where we map `fail/true` to "ja" and "da" based on a hidden language member of WorldState: 
```prolog
get_utterance(true, da_yes, da).
get_utterance(fail, da_yes, ja).
get_utterance(true, da_no, ja).
get_utterance(fail, da_no, da).

query_position(Position, Question, WorldState, Language, Utterance) :-
    ... % Otherwise unchanged.
    % Map Logical Result to Utterance based on Language
    get_utterance(LogicalAns, Language, Utterance).
```

## Optimization

### Bounding question grammar complexity
Now - if we were willing to wait infinitely long for our program to run, we would be done - but if you tried to solve the three gods puzzle with the Prolog program as described so far you would find it just hangs (possibly) indefinitely. This shouldn't be too surprising, after all, Prolog's engine uses naive depth first search and backtracking to explore our question grammar, which is unconstrained and allows for questions of arbitrary complexity.

So our first step is to add complexity bounds to our grammar limiting how many times we can compose and translate questions into more complex questions. Here is an example for a couple of our grammar rules:
```prolog
% Questions about how gods at positions might respond to questions.
is_question(NumPos, MaxQDepth, query_position_question(Pos, Q)) :-
    MaxQDepth > 0, % Only recurse if we have budget
    NextQDepth is MaxQDepth - 1,
    is_position(NumPos, Pos),
    is_question(NumPos, NextQDepth, Q).

% Recursive rules for AND.
is_question(NumPos, MaxQDepth, (Q1, Q2)) :-
    MaxQDepth > 0,
    NextQDepth is MaxQDepth - 1,
    is_question(NumPos, NextQDepth, Q1),
    is_question(NumPos, NextQDepth, Q2).
```

### Logical question deduplication 
Unfortunately - although we've guaranteed our program will exhaustively search all possible solutions using questions under a given complexity bound in finite time - in practice this program does not terminate in reasonable amount of time (I didn't have a strict time limit but I was aiming for about 1 minute). 

In fact, I was even unable to exhaustively expand my question grammar for **a single question even for complextiy bound 2**. This test below would consistently timeout:
```prolog
test('Exhaustive search proves [truly] vs [random] is indistinguishable for 1 Q^2 question') :-
    % We are asserting that the following goal MUST FAIL.
    % The '\+' operator succeeds if its argument fails completely.
    call_with_time_limit(10, \+ is_distinguishing_tree_bounded(
           1, % Num Positions
           1, % Tree Depth (Num Questions)
           2, % Max Question Complexity
           [truly, random],
           _Tree,
           generate_uniform_families
       )).
```

I was a little surprised - but - upon some thought I realized this made sense.
- We have $14$ base cases for questions
  - $2$ atomic questions (axiomatically true and false)
  - $3x3$ cases for questions about specific god types being at specific questions 
- For a set of questions of complexity $C$ ($Q^C$) with size $N$ - we have $3 + 3*N^2$ ways to produce new questions of complexity $C+1$
  - For each question $Q$, we can make $3$ new ones with questions of the form "Would the god at position $p$ respond to $Q$ with "da". I guess technically we could also produce conjugate questions for "ja", but in practice my grammar didn't do this.
  - For each pair of questions $Q_i, Q_j$, we can produce new questions $Q_i \land Q_j$, $Q_i \lor Q_j$, $Q_i \oplus Q_j$. (I added a rule for XOR because the solution I came up w/ used it as a conditional inversion operator, even though the standard solutions online don't use it)

So - putting this together we have
- $14$ questions of complexity $0$ ($Q^0$ questions)
- $3 + 3*14^2 = 591$ questions of complexity $1$ ($Q^1$ questions)
- $3 + 3*591^2 = 1e6$ questions of complexity $2$ ($Q^2$ questions)

I'm still a little surprised I can't evaluate a million questions in 10 seconds, but - oh well - can't argue with a hanging terminal.

Now - it turns out we don't need $Q^2$ questions to solve this puzzle - $Q^1$ questions are fine. But one of my goals here was to make a more general solver for these types of puzzles. As a followup - for example - I might be interested in adding a puzzle grammar to find puzzles that can't be solved using $Q^1$ questions and instead require $Q^2$ or even $Q^3$ questions. So I think this is a problem that needs to be solved.

Actually this stumped me for a long time. I went down some truly labyrthine rabbit holes trying to solve this. I tried some hueristics, but I really didn't want to go that route. If I gave my solver a puzzle and it couldn't find a solution - I wanted to be sure that a solution didnt exist, as opposed to wondering if my hueristic just pruned it. Anyways the hueristic approach didnt work regardless of my misgivings. I had an interesting idea about co-generating less complex versions of the puzzle using a puzzle grammar - and then as I made my puzzles more complex using the grammar rules, I would only do so if I could find questions that ensured they remained solveable. I still think theres something useful there but I couldn't make work. And - anwyays my job got busy. So I gave up a for a couple months.

Eventually my girlfiend (who was visiting family at the time) returned and we began talking about whatever happened to my stupid little Prolog project. I was walking her through the approaches I tried and as we talked we began to think about what makes a useful question. And specifically how we could prevent our grammar from mindlessly composing useless questions with useless questions, creating a combinatorial explosion of useless questions. We realized (and I really do think we jointly came up with this idea) that the domain of "useful" questions for this puzzle world is fairly limited. We only only have 6 possible permutations of gods, and each permutation can only answer a question one of 3 ways:
1. ja
2. da
3. or either - since the question could've been posed to the Random god

So there are only $3^6=729$ useful questions!

After implementing question deduplication by their "logical signature" - I found that not only did this greatly speed up question generation - we could produce all useful `Q^2` questions in less than 1 second - we could actually produce every possible useful question using just `Q^3` questions (and do so in less than 30 seconds). So - in a sense - we were able to exhaustively search our question grammar.

### Early question tree pruning

Now - theres one more optimization I implemented. You may remember that a full question tree for 3 questions has 7 nodes. Even w/ our greatly reduced question domain - $729^7$ is waaaaayyy too many question trees. So we also implemented some tree pruning ensuring we stopped exploring trees when a subnode contained too many permutations to solve with our remaining questions. 

For example, lets say we pick "Is 1==1?" as our starting question and ask it to the god in the first position. What are the possible responses for each permutation of the gods?
- TFR: either "ja" or "da" depending on the meaning of the gods language
- TRF: ditto
- FTR: ditto
- FRT: ditto
- RTF: either "ja" or "da" - this time depending on the mental state of the Random god
- RFT: ditto

So now in both the left and right subtree for this question, we have 6 permutations to distinguish with only 2 questions (a max of 4 is possible). Therfore we can discard this question and all trees deriving from it.

How effective is this pruning? I added some telemetry to my prolog puzzle to analyze exploration/pruning statistics when solving the full riddle and found that we pruned all but a couple of questions at each level our question tree. One thing that surprised me is how few questions we actually explore at each depth level. We don't get anywhere close to exploring all 729 (actually its 365 b/c I use conjugate symmetry to cut down the question space) possible questions - which is probably why this problem is tractable at all in Prolog.
```txt
│ INFO: --- SEARCH STATISTICS ---                                                                                                                                                                                                                                                                                    │
│ INFO: Note: Tree Level 1 is the Root.                                                                                                                                                                                                                                                                              │
│ INFO: Level | Explored | Pruned | Ratio                                                                                                                                                                                                                                                                            │
│ INFO: -----------------------------------                                                                                                                                                                                                                                                                          │
│ INFO:   1   |    26   |   24   | 0.9230769230769231                                                                                                                                                                                                                                                                │
│ INFO:   2   |    351   |   347   | 0.9886039886039886                                                                                                                                                                                                                                                              │
│ INFO:   3   |    176   |   152   | 0.8636363636363636                                                                                                                                                                                                                                                              │
│ INFO: -----------------------------------                                                                                                                                                                                                                                                                          │
│ INFO: TOTAL | 553 | 523 | 0.945750452079566
```

I tried repeating this analysis for an unsolveable puzzle to get an idea of how many questions would be pruned if we fully explore our grammar - but what I found is that all questions would be instantly pruned for unsolveable problems. I do wonder if this optimization scales to different puzzles though - I could imagine an antagonistically constructed puzzle that causes the number of question trees passing this check to explode.

## Solution Playground (***Spoiler warning!***)
***Skip this section if you dont want the solution to the puzzle ruined!***

I've intentionally avoided talking about the actual solution to the 3-gods puzzle so I don't ruin the puzzle for you, but I think its time to show off the Prolog solver.

You can execute it in the playground below or use this [direct link](https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/final_solution.pl&q=solve_and_print_riddle.) to go to SWISH.

*NOTE: sometimes the sandbox kills my solver because it is too heavy. If that happens just run it locally: https://www.swi-prolog.org/download/stable.*

<iframe src="https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/final_solution.pl&q=solve_and_print_riddle." 
        width="100%" 
        height="600px" 
        style="border: 1px solid #ccc; border-radius: 4px;">
</iframe>

## Next Steps
Theres a few interesting directions for future work.

### Solving this puzzle in 2 questions
First, I think that it is probably possible to solve this puzzle in 2 questions if we allow pardoxical questions. These would be questions like - "Will you answer this question with something meaning "yes"?". Lets say the falsely god answers with "no" (in the god's language) - well - then it told the truth and violated its nature. But if the god answers `yes` - it has also told the truth and violated its nature. So it is impossible for the falsely god to answer this question and he must remain silent. 

Since it is now possible to get three diffrent responses to a question ("da"/"ja"/silence), in 2 questions we can now differentiate 9 worldstates - more than the 6 possible permutations of the gods.

Actually, someone explored this idea in [a paper](https://www.researchgate.net/publication/31366417_A_simple_solution_to_the_hardest_logic_puzzle_ever) and came to the same conclusion as me. But there was a [later paper](https://www.researchgate.net/publication/225580608_Why_the_Hardest_Logic_Puzzle_Ever_Cannot_Be_Solved_in_Less_than_Three_Questions) which provided a proof for why this puzzle is unsolveable with 2 questions even w/ paradoxical questions allowed. Having read the proof - I'm unconvinced - but since I have the ability to exhaustively search the question grammar for this puzzle - this is something I can easily and conclusively verify.

### Puzzle generation
Second, I think we could create a grammar to produce new puzzles. A simple such grammar would be one with 2 rules
1. Add a new position (or god). This would let us go from 3 to 4 gods. Or 4 to 5 etc...
2. Allow a new god type at a position. So - in our new position, we could allow e.g. the Truly god, or the Random god, etc...

A more complex grammar (the most complex and flexible such grammar) would be the Prolog language itself. Of course - I definitely couldn't meaningfully search over such a complex grammar using Prolog by itself - some kind of modern AI (LLM) would be required.

Once we can search over the the puzzle domain, we could look for and classify categories of puzzles. For example, we could find puzzles that require complexity 2 ($Q^2$) questions - or complexity 3 questions ($Q^3$) questions.

### SMT solving
Third, I think solving this puzzle really pushes the limits of what is possible in Prolog. If we want to solve much harder problems (as discussed above), we would probably need to switch to a more powerful version of logic programming - specifically a SMT solver.

I think that this could be as simple as converting the program to Datalog (https://en.wikipedia.org/wiki/Datalog), but it might be as involved as rewriting the solver in Z3/S3 (https://en.wikipedia.org/wiki/Z3_Theorem_Prover). It also might not be possible - I don't think I'm using any SMT incompatible formulation (my question grammar is finite) but I might be wrong.

### Neuro-Symbolic Reasoning
Lastly - and this is probably the most vague and poorly concieved idea - I had an idea that Prolog's search algorithm (which uses naive backtracking) could instead be replaced or augmented by an ML/AI hueristic. 

Obviously you would be taking a huge hit to the number unifications you attempt per second, but given how many bad unifications there are in a large search space (like in this puzzle) I think an intelligent search strategy could result in a successful unification sooner.

I think if you wanted to do RL, you could have a very dense and cheap signal. And this approach of using ML hueristic to search a exponentially huge space does seem to work well for games like Go, Arimaa, and chess - even at the scale of something a single person could train. And I even think your RL signal could be a lot more immediate and direct than game playing, where you have to finish a whole game to get feedback or rely on evaluation hueristics.





Looking only at the starting question, we are restricting our question domain to only those questions that have a maximum of 4 god permutations responding either "da" or "ja". How many permutations is this? Ahh ok - let me see - we can represent the logical signature of a question over a permutation of gods as a sequence of 6 tokens - where each token can take on one of three values representing possible responses of this permutation to this question ("da","ja", or either). This pruning only passes questions that have at most 4 permutations capable of answering "da" - and at most 4 permutations capable of answering "ja".

So we can think of this as dividing 6 balls into 3 groups $A$,$B$,$C$, where $A$ represents those permutations of gods who can only answer "ja" to a question, $B$ represents those permutations of gods who can answer either "ja" or "da" to a question, and "C" represents those permutations of gods who can only answer "da" to a question. Our constraints are then $|A+B| <= 4$, and $|B+C| <= 4$ or alternately $|A| >= 2$ and $|C| >= 2$. How many splits does this create? Uhhh - I guess we could elminate cases where $|A| \in {0,1}$? Thats - what - $2^6 = 64$ for $|A| = 0$ - and $\binom{6}{1} * 2^5 = 32 * 6 = 192$ for $|A| = 1$? So a total of $256$ bad cases for $A$ ?(and same for $C$). 







Now - I knew that we could 

The full question grammar,our real question grammar (displayed below) is a lot more complex than the toy grammar explored earlier:
```prolog
% Base Case 1: Trivial questions are allowed.
is_question(_, _, true).
is_question(_, _, fail).

% Base Case 2: Questions about the world are allowed.
is_question(NumPos, _, at_position_question(Pos, God)) :-
    is_position(NumPos, Pos), is_god(God).

% Base Case 3: Questions about how gods at positions might respond to questions are allowed.
is_question(NumPos, MaxQDepth, query_position_question(Pos, Q)) :-
    MaxQDepth > 0, % Only recurse if we have budget
    NextQDepth is MaxQDepth - 1,
    is_position(NumPos, Pos),
    is_question(NumPos, NextQDepth, Q).

% Recursive rules for AND, OR, XOR.
is_question(NumPos, MaxQDepth, (Q1, Q2)) :-
    MaxQDepth > 0,
    NextQDepth is MaxQDepth - 1,
    is_question(NumPos, NextQDepth, Q1),
    is_question(NumPos, NextQDepth, Q2).

is_question(NumPos, MaxQDepth, (Q1 ; Q2)) :-
    MaxQDepth > 0,
    NextQDepth is MaxQDepth - 1,
    is_question(NumPos, NextQDepth, Q1),
    is_question(NumPos, NextQDepth, Q2).

is_question(NumPos, MaxQDepth, (Q1 xor Q2)) :-
    MaxQDepth > 0,
    NextQDepth is MaxQDepth - 1,
    is_question(NumPos, NextQDepth, Q1),
    is_question(NumPos, NextQDepth, Q2).
```

Additionally, even though I added complexity bounds to constrain grammar exploration


Now - instead of checking that a question's answer is different for the 2 possible worldstates, we have to check that the question's 
Multiple questions are a lot harder.



So - to summarize - this grammar supports:
1. axiomatically true questions
2. questions about how the god in front of us will answer an axiomatically true question
3. questions about how the god in front of us will answer questions about how the god in front of us will answer an axiomatically true question
4. questions about how the god in front of us will answer questions about how the god in front of us will answer questions about how the god in front of us will answer an axiomatically true question

... and so on and so forth. 

But - only questions 1 & 3 above are useful in determining whether the god in front of us is Truely or Falsely (or you know - any odd #ed question above.)

We also need a way to pose these questions to gods at a specific position 

Instead I want to talk about a formal method of solving this puzzle I came up with - and which I don't think anyone's ever done before.

My solution, was to identify a non-random god with the 1st question, determine his identity with the 2nd question, and determine the identity of the other 2 gods w/ the 3rd question. This is

From the start I had a pretty good idea of how to handle the language barrier. Lets say we have any arbitary binary question $Q$ that evaluates the truthfullness of proposition $P$ - "Is $P$ true?"$. The proposition $P$ can be "translated" into the language of the gods by conditional inversion with the proposition "`da` means `True`". We can use this to create a question $Q'$ where the answer `da` means the god would've answered `yes` in English - "Is ($P$ XOR "`da` means `True`") true?"$ (remember that XOR is the operator for conditional inversion).

Ok - so that handles the ja/da aspect of the riddle - but how do we solve the problem even if the gods just answer in English (yes/no)? The crux of this problem is the random god. Because he gives random answers - if you pose a question him (which can't be avoided for every arrangement of gods) it gives you no information.

My initila strategy was to ask a non-random god whether the next answer of the random god will be true or false (by true or false I mean - the answer given by the random god is true or false). We can guarantee this by asking two diferent gods the same question - one of them is now guaranteed to be a non-random god. This makes it so that the next question posed to a random god will have a known true/false value - which sounds good - but actually guarantees that we can't solve this puzzle with our remaining questions (actually just question).

Why? We are wasting a question learning something irrelevant about the world. There are $3! = 6$ possible arrangements of the gods - requiring $log_2(6) = ~2.5$ bits to constrain. Since we only have 3 questions - we can't waste any question learning something about the random god's answer. If we wanted to learn the truth value of the random god's first answer and the arragement of the gods we would need $\lceil log_2(6*2) \rceil = \lceil 3.5 \rceil = 4$ questions. (This also means we have to solve this puzzle without learning the language of the gods.)

I also briefly considered using paradoxical questions

Eventually I settled on a strategy of identifying a non-random god in the 1st question, determining its identity (truly or falsely) in the 2nd question, and determining the identities of the



- 1.pl
  - establishes approach of "distinguishing question" - allows us to find qudestions that can distinguish a single god who may be of tyopes truly or falsely
- 2.pl
  - supplies worldstate to question evaluation - previosuly question evaluation unconstaoined by worldstate
- 3.pl
  - adds random god - random gods answers are modeled as predetermined states upon world construction
  - ofc - the truly and random gods are indistinguishable - so this program always hangs
- 4/5.pl
  - adds multiple positions (3) to our world - previosuly there was only a single god in front of us
  - ofc there are no distinguishing questions for 3 gods (we need multiple questions)
- 6.pl
  - establishes approach of generating trees to partition families - but hangs when solving full complexity 3 gods problem
- 7.pl
  - adds an early stopping condition to tree generation - where - if # of familes we have to parition at any node in tree path is > 2 ^ questions left - we early stop
  - wasnt working
- 8.pl
  - adds a bunch of testing to debug 7
  - eventually realized that fully evaluating a question of the required complexity for our gramamr is too expensive by itself - some back of envelope math gives 100k possibel questions of complexity 2 (we know golden question has complexity 2)
- 8a
  - Deduplicates questions by how they partition god permutations
- 8b
  - supoprt for ja/da language - also optimizes question deduplicatoin
- 9.pl
  - tries a new a approach were we only compose questions (make them more complex) - if it "impoves" the way they partition our families
  - it prunes too aggressively - trivially true quesiotn 1==1 is the "ideal" question from a partitioniong perspective - but we know it doens't form part of the ultimate golden questikon
- 10/11/12
  - explores idea of co generating the problem along side our questions
  - focuses on the step of decomposing the full complexity probnlem into 2 subproblems - 1 where R isn't allowed at position 2 and 1 where R isn't allowed at position 3
  - these 2 subprobklems can be solved in 2 questions each
  - the golden question "is the random god directly adjacent and to thje righbt of hte true god" - when posed to position 1 - differentiates these 2 subproblems
  - wasnt abel to get this to work - but i think it should be possible - just errors in code (we can exhaustively search the complexity 2 grammar)
