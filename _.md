- 1.pl
  - establishes approach of "distinguishing question" - allows us to find qudestions that can distinguish a single god who may be of tyopes truly or falsely
- 2.pl
  - supplies worldstate to question evaluation - previosuly question evaluation unconstaoined by worldstate
- 3.pl
  - adds random god - random gods answers are modeled as predetermined states upon world construction
  - ofc - the truly and random gods are indistinguishable - so this program always hangs
- 4/5.pl
  - adds multiple positions (3) to our world - previosuly there was only a single god in front of us
  - ofc there are no distinguishing questions for 3 gods (we need multiple questions)
- 6.pl
  - establishes approach of generating trees to partition families - but hangs when solving full complexity 3 gods problem
- 7.pl
  - adds an early stopping condition to tree generation - where - if # of familes we have to parition at any node in tree path is > 2 ^ questions left - we early stop
  - wasnt working
- 8.pl
  - adds a bunch of testing to debug 7
  - eventually realized that fully evaluating a question of the required complexity for our gramamr is too expensive by itself - some back of envelope math gives 100k possibel questions of complexity 2 (we know golden question has complexity 2)
- 9.pl
  - tries a new a approach were we only compose questions (make them more complex) - if it "impoves" the way they partition our families
  - it prunes too aggressively - trivially true quesiotn 1==1 is the "ideal" question from a partitioniong perspective - but we know it doens't form part of the ultimate golden questikon
- 10/11/12
  - explores idea of co generating the problem along side our questions
  - focuses on the step of decomposing the full complexity probnlem into 2 subproblems - 1 where R isn't allowed at position 2 and 1 where R isn't allowed at position 3
  - these 2 subprobklems can be solved in 2 questions each
  - the golden question "is the random god directly adjacent and to thje righbt of hte true god" - when posed to position 1 - differentiates these 2 subproblems
  - wasnt abel to get this to work - but i think it should be possible - just errors in code (we can exhaustively search the complexity 2 grammar)

I was introduced to the 3-gods problem (somewhat cruelly) a few months ago by a college friend while we were catching up over some bbq. I can't remember what we were talking about - but I do remember him saying something along the lines of "Here's a very easy logic problem for you (very )

A few months ago I was catching up with a friend over some barbeque and he posed an interesting logic puzzle to me:

"Heres an easy riddle (I'm paraphrasing): there are 3 gods in front of you, one who always answers truely, one who always answers falsely, and one who always answers randomly. Your goal is to determine the identity of each code using 3 yes/no questions. Oh - and the gods answer in their own language although they understand English. So they will answer with ja/da - and you don't know which means yes and which means no."

Well - I can't remember what we were talking about before - but I guess I must have been razzing him b/c this is not an easy problem! Famously - this is the so-called "Hardest Logic Puzzle Ever" (https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever). Well - he got me (I think the term is nerd-sniping?). I thought about it a good deal on the drive home - and that night - and the day after - and the day after that ---- actually it took me a long time to figure this one out.

If you  writeups and explanations are available on wikipedia (https://en.wikipedia.org/wiki/The_Hardest_Logic_Puzzle_Ever#Solutions).

Instead I want to talk about my formal method of solving this problem with logic programming - which AFAIK no one has actually done before.

 (although you could definitely also frame this as a SMT problem and solve it using S3 or something). I actually think this a novel approach - to the best of my knowledge no one has ever solved this problem using logic programming of any kind.

After solving this puzzle - I had the idea that it might be interesting to solve this problem using a more formal methid. I spent a little time trying to solve it with boolean algebra (actually someone wrote a [paper](https://www.researchgate.net/publication/339489184_Solving_Knights-and-Knaves_with_One_Equation) doing just this) - but I just couldn't quite make it work. Once I had an objective in mind (say - determining the identity of a non-random god), I was able to write a system of equations and plug them into mathmatica to produce a question that allowed me to achieve my objective, but I wasn't able to formalize the process of arriving at an objective. And then I had absolutely no idea how to further extend this approach to handle branching logic and question trees.

Eventually I remembered some week long unit from my programming languages class on Prolog. Prolog is a delarative programming language (like SQL, or I guess tensorflow v1?) as opposed to imperative programming languages like Python/C++/go/rust/etc... (also tensorflow v2). What you do is specify known facts about the world (e.g. sky is blue, I am looking at the sky) and let Prolog's engine solve for unknowns (The color of the thing I am looking as is \_\_\_\_ --- and in this case Prolog would fill in `blue` for the blank).

Lets see how we might use Prolog to solve a much simpler problem. Say there is a single god in front of us, who may be either the Truely or Falsely god - and we want to determine its identity in 1 question. As a human - easy - just ask the god a trivially true question like "Is 1 == 1?". If they say yes - they are the Truely god - if they say no they are the falsely god. For Prolog to discover this same question - we need
1. Constraints defining the world (a single god, who may be of 2 different types, each of which who answer questions differently)
2. Constraints on questions - here we define a grammar. For this world we only need the atomic trivially true question mentioned earlier, but we can also add some other grammar rules. For example, composition via AND and OR operators, etc... 
3. Constrains on how questions are evaluated by our world. This is where we encode our objective - which is that our desired question can differentiate the possible worldstates. Or - in other words - that when we pose our question tothe god in front of us,  it yields different responses for different worldstates.

What does this actually look like?

World constraints are very simple - we have a single position, and it may be inhabited by 2 different gods:
```prolog
is_position(a).

is_god(truly).
is_god(falsely).
```

Similarly our question grammar can be very simple. We only need an "atomic" true question - which we can imagine as "Is 1==1?" or some other axiomatic statement. But thats a little boring - lets at least give our Prolog program a chance to fail and ask a useless question. For example - "Will the god at position `a` answer the question "1==1" with yes?". The Truely - god - truthfully - will say yes. The Falsely god - deceitfully - will also say yes.
```prolog
% Axiomatically true questions are allowed.
is_question(true).

% Questions about how gods at positions might respond to questions are allowed.
is_question(query_position_question(Pos, Q)) :- is_position(Pos), is_question(Q).
```

This question grammar requires a corresponding evalaution framework - for this we define an evaluation predicate `evaluate(Question, WorldState)`: 
```prolog
% Note that axiomatic questions do not require the worldstate for evaluation
evaluate(true, _) :- true.

% (`query_position` is the predicate which evalautes the result of posing a question to a God. It is explained in more detail below - because we allow self-referential questions explaining this code creates a bootstrapping problem :O)
evaluate(query_position_question(P, Q), WS) :- query_position(P, Q, WS).
```

We encode the different behavior of the gods by how they evaluate questions - the Truly god returns the logical value of the proposition 
represented by a question as evaluated by Prolog's engine - the Falsely god returns its negation:
```prolog
query(truly, Question, WorldState) :-
    evaluate(Question, WorldState).

% (\+ is the negation operator in Prolog)
query(falsely, Question, WorldState) :-
    \+ evaluate(Question, WorldState).
```

We also need a way to pose these questions to gods at a specific position:
```prolog
query_position(Position, Question, WorldState) :- 
        is_position(Position), is_god(GodType), query(GodType, Question, WorldState).
```

Finally we can synthesize the constraints above with a predicate that forces the 2 possible worldstates (the god in front of you is Truely or Falsely) to give different responses for a question:
```prolog
is_distinguishing_question(Question, AnswerForTruly, AnswerForFalsely) :-
    is_question(Question),
	(query_position(a, Question, truly)
    	-> AnswerForTruly = true ; AnswerForTruly = fail),
    (query_position(a, Question, falsely)
    	-> AnswerForFalsely = true ; AnswerForFalsely = fail),
    AnswerForTruly \= AnswerForFalsely.
```

The predicate above can be used in 2 ways:
1. We can invoke it w/ an unconstrained question: `is_distinguishing_question(Q, _, _).`. This will produce all distinguishing questions (you can cycle through all results w/ `;`).
2. We can also invoke it 

You can play around w/ this simplified problem and its solution in the embedded playground below ([full screen](https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/knight_or_knave.pl&q=is_distinguishing_question(Q,_,_).)):

<iframe src="https://swish.swi-prolog.org/?code=https://raw.githubusercontent.com/aduriseti/3gods/main/knight_or_knave.pl&q=is_distinguishing_question(Q,_,_)." 
        width="100%" 
        height="600px" 
        style="border: 1px solid #ccc; border-radius: 4px;">
</iframe>

So - to summarize - this grammar supports:
1. axiomatically true questions
2. questions about how the god in front of us will answer an axiomatically true question
3. questions about how the god in front of us will answer questions about how the god in front of us will answer an axiomatically true question
4. questions about how the god in front of us will answer questions about how the god in front of us will answer questions about how the god in front of us will answer an axiomatically true question

... and so on and so forth. 

But - only questions 1 & 3 above are useful in determining whether the god in front of us is Truely or Falsely (or you know - any odd #ed question above.)

We also need a way to pose these questions to gods at a specific position 

Instead I want to talk about a formal method of solving this puzzle I came up with - and which I don't think anyone's ever done before.

My solution, was to identify a non-random god with the 1st question, determine his identity with the 2nd question, and determine the identity of the other 2 gods w/ the 3rd question. This is

From the start I had a pretty good idea of how to handle the language barrier. Lets say we have any arbitary binary question $Q$ that evaluates the truthfullness of proposition $P$ - "Is $P$ true?"$. The proposition $P$ can be "translated" into the language of the gods by conditional inversion with the proposition "`da` means `True`". We can use this to create a question $Q'$ where the answer `da` means the god would've answered `yes` in English - "Is ($P$ XOR "`da` means `True`") true?"$ (remember that XOR is the operator for conditional inversion).

Ok - so that handles the ja/da aspect of the riddle - but how do we solve the problem even if the gods just answer in English (yes/no)? The crux of this problem is the random god. Because he gives random answers - if you pose a question him (which can't be avoided for every arrangement of gods) it gives you no information.

My initila strategy was to ask a non-random god whether the next answer of the random god will be true or false (by true or false I mean - the answer given by the random god is true or false). We can guarantee this by asking two diferent gods the same question - one of them is now guaranteed to be a non-random god. This makes it so that the next question posed to a random god will have a known true/false value - which sounds good - but actually guarantees that we can't solve this puzzle with our remaining questions (actually just question).

Why? We are wasting a question learning something irrelevant about the world. There are $3! = 6$ possible arrangements of the gods - requiring $log_2(6) = ~2.5$ bits to constrain. Since we only have 3 questions - we can't waste any question learning something about the random god's answer. If we wanted to learn the truth value of the random god's first answer and the arragement of the gods we would need $\lceil log_2(6*2) \rceil = \lceil 3.5 \rceil = 4$ questions. (This also means we have to solve this puzzle without learning the language of the gods.)

I also briefly considered using paradoxical questions

Eventually I settled on a strategy of identifying a non-random god in the 1st question, determining its identity (truly or falsely) in the 2nd question, and determining the identities of the



